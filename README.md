# UniqCounter
Second task for intershipVk
## Задача
Необходимо написать алгоритм, который приблизительно подсчитывает количество различных чисел в массиве, используя константный объём памяти. 

Более формально, надо реализовать класс с двумя функциями:

* `void add(int x);` — добавить число x к набору;
* `int get_uniq_num();` — возвращает приблизительное количество различных чисел, которые были переданы в функцию `add`.

Ваш класс должен использовать не более 32 Кб памяти.
## Решение

_Благодаря_ _этому_ _заданию_ _в_ _мире_ _стало_ _на_ _N_ _реализаций_ _HypperLogLog_ _больше_. _Не_ _думаю_, _что_ _он_ _нуждается_ _в_ _еще_ _одной_

Идея реализованного алгоритма подсмтрена [в обсуждении на форуме](https://www.rsdn.org/forum/alg/2295710)

### Алгоритм

Заведем массив пар `ranges`, в котором будем хранить интервалы, которым принадлежат входные данные. Колличество элементов в массиве ограничено свехру выделенной памятью.

    входные данные: 2 3 8 5 10 12 4 11
    ranges: {2,5} {8,8} {10,12}
    
Когда надо добавить число в набор, либо добавляем его уже к существующему интервалу (объединяя соседние интервалы, если данное число было единственным между ними), либо добавляем число как отдельный интервал, если приписывать было не к чему.

Если надо добавить элемент как отдельный интервал, но выделенная память закончилась, находим два ближайших друг к другу интервала (с учетом добавляемого числа) и объединяем их в один, после чего добавляем новый интервал. Разницу между слитыми интервалами добавим к переменной `error` — отвечает за количество "ошибочно" добавленных элементов в массив.

Если добавляемый элемент уже есть в массиве, то он будет ошибочным с вероятность `error / covered`, где `covered` — сумма всех интервалов в массиве. Пересчитаем значение ошибки с учетом этого.

Ответом будет `covered - error`.

### Асимптотика

Будем поддерживать массив отсортированным. Тогда поиск места для вставки элемента будем производить за `O(logN)`, вставку и удаление диапазонов — за `O(N)`. Итоговая асмптотка получится `O(M*N)`, где `M` — количество элементов в обрабатываемом массиве, а `N` — максимальное количество диапазонов, поддерживаемых в `ranges`.

### Память

Затрачиваемая память расчитывается из желаемого количества диапазонов. Данная реализация использует чуть больше 3Кб памяти и поддерживает не больше 384 интервалов.
